# 🧹 **SOP: Terraform Format & Validate — Clean, Error-Free Infrastructure Code** 🧱✨

---

## 🎯 **Goal**

Keep Terraform configurations **clean, standardized, and error-free** before applying them to production.
Two core commands make this possible:

* `terraform fmt` → Formats your code
* `terraform validate` → Checks for syntax & logical errors

---

## 🧠 **Why It Matters**

| 🔢 | Concept              | 💡 Importance                                                               |
| -- | -------------------- | --------------------------------------------------------------------------- |
| 🧩 | **Consistency**      | Ensures all Terraform files follow the same indentation and layout.         |
| ⚙️ | **Automation**       | Prevents messy diffs in version control (Git).                              |
| 🚨 | **Error Prevention** | Detects invalid syntax or wrong references before running `terraform plan`. |
| 🧱 | **DevOps Practice**  | Used in CI/CD pipelines for Terraform quality checks.                       |

---

## 🪜 **Step-by-Step SOP**

---

### 🥇 Step 1: Open Your Terraform Project 📂

Navigate to your project folder:

```bash
cd terraform-project/
```

💡 *Make sure your `.tf` files are inside this folder (e.g., `main.tf`, `provider.tf`, etc.)*

---

### 🥈 Step 2: Format the Code 🧼

Run the formatting command:

```bash
terraform fmt
```

✅ **What it does:**

* Aligns `=` signs
* Fixes indentation
* Normalizes spacing
* Formats nested blocks

Example:
Before 👇

```hcl
resource "aws_instance" "myec2"{
ami="ami-0dee22c13ea7a9a67"
instance_type= "t2.micro"}
```

After running `terraform fmt` 👇

```hcl
resource "aws_instance" "myec2" {
  ami           = "ami-0dee22c13ea7a9a67"
  instance_type = "t2.micro"
}
```

💡 **Use Case:**
Ensures consistency across your team — same formatting style, no confusion in Git diffs.

---

### 🥉 Step 3: Validate Configuration ✅

Run:

```bash
terraform validate
```

✅ **What it does:**

* Checks for **syntax errors**
* Detects **wrong variable references**
* Validates **provider and resource configuration**

Example output:

```
Success! The configuration is valid.
```

If there's an issue, you might see:

```
Error: Missing required argument
```

💡 **Use Case:**
Validates logic before running costly `terraform apply`.

---

### 🧠 Step 4: Combine Both in CI/CD Pipelines 🧰

You can automate both checks before deployment:

```bash
terraform fmt -check
terraform validate
```

💡 **Best Practice:**
Add these steps in Jenkins, GitHub Actions, or GitLab CI pipelines to fail early if syntax or format is wrong.

---

### 🧾 Step 5: Summary Table

| Step | Action              | Command                                       | Result / Use Case               |
| ---- | ------------------- | --------------------------------------------- | ------------------------------- |
| 🥇   | Navigate to project | `cd terraform-project/`                       | Access working directory        |
| 🥈   | Format files        | `terraform fmt`                               | Standardize code layout         |
| 🥉   | Validate files      | `terraform validate`                          | Detect syntax or logical issues |
| 🧠   | CI/CD integration   | `terraform fmt -check` + `terraform validate` | Automated quality gate          |

---

### ⚡ Bonus Tip — Check All Files Recursively 🔍

To format **all Terraform files** in subdirectories:

```bash
terraform fmt -recursive
```

---

### 🚀 Real DevOps Use Case

When working in a **shared Git repo**, run:

```bash
terraform fmt
terraform validate
git add .
git commit -m "Formatted and validated Terraform code"
```

This ensures every commit maintains:
✅ Clean format
✅ Valid syntax
✅ Team-wide consistency

---

### 🔥 Output Example

```
terraform fmt
main.tf
provider.tf
s3.tf

terraform validate
Success! The configuration is valid.
```

---

### 🧩 Final Thought

These two commands are small but **critical DevOps practices**.
They make Terraform projects production-ready by ensuring:
✅ Readability
✅ Reliability
✅ Team consistency

---
