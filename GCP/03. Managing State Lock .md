# 🧱 SOP: Storing Terraform State in GCS, Creating a VM, and Managing State Lock

---

## 🧩 PART 1 — Create the GCS Bucket for Terraform State

### 🎯 Objective

Create a Google Cloud Storage (GCS) bucket to securely store Terraform’s state file, enabling centralized, versioned, and recoverable infrastructure management.

### 🧠 Why Store Terraform State Remotely?

| 🔍 Aspect         | 💡 Description                                  | 🚀 Benefit                             |
| ----------------- | ----------------------------------------------- | -------------------------------------- |
| Collaboration     | Multiple engineers share the same state         | Prevent conflicts and overwrites       |
| Backup & Recovery | GCS provides versioning and replication         | Rollback accidental changes            |
| Consistency       | Remote state ensures same infra data            | Avoid drift between local & real-world |
| Security          | GCS supports IAM and encryption                 | Protect sensitive data                 |
| Automation Ready  | CI/CD pipelines and Terraform Cloud integration | Seamless automation                    |

### 🧱 Terraform Configuration (main.tf)

```hcl
provider "google" {
  project = "your-gcp-project-id"
  region  = "asia-south1"
}

resource "google_storage_bucket" "tf_state_bucket" {
  name          = "my-tf-state-bucket-12345"  # Must be globally unique
  location      = "ASIA-SOUTH1"
  force_destroy = true

  versioning {
    enabled = true  # Keep history of state versions
  }

  lifecycle_rule {
    action {
      type = "Delete"
    }
    condition {
      age = 365
    }
  }
}

output "bucket_name" {
  value = google_storage_bucket.tf_state_bucket.name
}
```

### ⚙️ Execution Steps

1. Save the file as `main.tf`
2. Run `terraform init`
3. Run `terraform apply -auto-approve`
4. Verify bucket: `gsutil ls`

✅ **Expected Result:** GCS bucket created with versioning enabled.

---

## ⚙️ PART 2 — Initialize Terraform Backend (GCS) and Create a VM

### 🎯 Objective

Use the GCS bucket as a remote backend and deploy a Compute Engine VM.

### 🧱 Terraform Configuration (main.tf)

```hcl
provider "google" {
  project = "your-gcp-project-id"
  region  = "asia-south1"
}

terraform {
  backend "gcs" {
    bucket = "my-tf-state-bucket-12345"
    prefix = "terraform/state"
  }
}

resource "google_compute_instance" "vm_instance" {
  name         = "vm-sandeep-1"
  machine_type = "e2-micro"
  zone         = "asia-south1-a"

  boot_disk {
    initialize_params {
      image = "ubuntu-os-cloud/ubuntu-2204-lts"
    }
  }

  network_interface {
    network       = "default"
    access_config {}  # Enables external IP
  }

  metadata = {
    ssh-keys = "sandeep:${file("~/.ssh/id_rsa.pub")}"
  }

  tags = ["terraform-demo"]
}
```

### ⚙️ Execution Steps

1. Ensure bucket exists
2. Initialize backend: `terraform init -migrate-state`
3. Apply: `terraform apply -auto-approve`
4. Verify backend: `gsutil ls -r gs://my-tf-state-bucket-12345/terraform/state/`
5. Verify VM: `gcloud compute instances list`

✅ **Expected Result:** Remote state stored in GCS, VM created successfully.

---

## 🧩 PART 3 — Enable and Manage Terraform State Locking

### 🎯 Objective

Prevent concurrent modifications of Terraform state by enabling **state locking** on GCS, ensuring safe team collaboration.

### 🧠 Why State Locking?

| 🔑 Aspect         | 💡 Description                                 | 🚀 Benefit                                |
| ----------------- | ---------------------------------------------- | ----------------------------------------- |
| Prevent Conflicts | Only one Terraform operation can run at a time | Avoids corruption of `terraform.tfstate`  |
| Team Safety       | Multiple engineers can work safely             | Ensures consistent infrastructure changes |
| Recovery          | Stale locks can be identified and removed      | Prevents pipeline blocking                |
| Automation Ready  | Works in CI/CD pipelines                       | Secure, automated deployments             |

### 🧱 Terraform State Lock in GCS

Terraform uses **`.tflock` files** in the GCS bucket to implement locking automatically.

#### Steps to Enable and Use State Lock:

1. Ensure **bucket versioning is enabled** (done in Part 1)

2. Configure **remote backend** pointing to the bucket (Part 2)

3. Apply Terraform:

   ```bash
   terraform apply
   ```

   Terraform automatically creates a `.tflock` file in GCS for the current operation.

4. **Simulate concurrent apply:**

   * Run `terraform apply` in two terminals simultaneously
   * The second terminal will show:

   ```
   Error: Error acquiring the state lock
   ```

   ✅ Confirms lock is active

5. **Resolve Stale Locks:**
   If a lock is left due to failure:

   ```bash
   gsutil rm gs://my-tf-state-bucket-12345/terraform/state/default.tflock
   ```

   > Only delete after confirming no operations are running

### 🧠 Key Notes

* **Static Backend Config:** Backend cannot use variables; hardcoded values required
* **Re-init Required:** Run `terraform init` after backend changes
* **IAM Requirements:** `roles/storage.admin` or `roles/storage.objectAdmin` for the service account
* **State Protection:** GCS versioning allows rollback of state file

---

## 🧹 Cleanup

```bash
terraform destroy -auto-approve
```

* Because `force_destroy = true`, the bucket and VM will be deleted even if objects exist.

---

## 🏁 Final Outcome Summary

| ✅ Component          | 🧱 Description                                          |
| -------------------- | ------------------------------------------------------- |
| 🪣 GCS Bucket        | Centralized remote backend for Terraform state          |
| 🧠 Versioning        | Tracks and protects state changes                       |
| ⚙️ Remote Backend    | Enables team collaboration and automation               |
| 🔒 State Lock        | Prevents concurrent Terraform operations                |
| 💻 Compute Engine VM | Example infrastructure deployed from Terraform          |
| 🔐 IAM Control       | Ensures secure, controlled access                       |
| 📈 Scalability       | Ready for multi-user, multi-environment Terraform usage |

---
